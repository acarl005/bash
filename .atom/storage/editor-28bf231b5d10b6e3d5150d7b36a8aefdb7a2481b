{"version":1,"windowDimensions":{"x":65,"y":24,"width":1855,"height":1056,"maximized":true},"grammars":{"grammarOverridesByPath":{}},"project":{"deserializer":"Project","paths":["/home/andy/Desktop/bower_components"],"buffers":[{"id":"cc561ac6c75132bfacd5e55dfef5711e","text":"{\n  \"name\": \"generatorics\",\n  \"homepage\": \"https://github.com/acarl005/generatorics\",\n  \"_release\": \"8114c43822\",\n  \"_resolution\": {\n    \"type\": \"branch\",\n    \"branch\": \"master\",\n    \"commit\": \"8114c43822e465c2e2a92545059e3f840d7414a9\"\n  },\n  \"_source\": \"git://github.com/acarl005/generatorics.git\",\n  \"_target\": \"*\",\n  \"_originalSource\": \"generatorics\",\n  \"_direct\": true\n}","defaultMarkerLayerId":"0","markerLayers":{"0":{"id":"0","maintainHistory":false,"markersById":{"4":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":1}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap"},"5":{"range":{"start":{"row":13,"column":0},"end":{"row":13,"column":1}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap"},"6":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":1}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap"},"7":{"range":{"start":{"row":13,"column":0},"end":{"row":13,"column":1}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap"}},"version":2},"1":{"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"id":"2","maintainHistory":true,"markersById":{"1":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2},"3":{"id":"3","maintainHistory":false,"markersById":{},"version":2},"4":{"id":"4","maintainHistory":false,"markersById":{},"version":2}},"nextMarkerLayerId":5,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/home/andy/Desktop/bower_components/generatorics/.bower.json","digestWhenLastPersisted":"6d7d4968810bf839e9ab36a407a7c738b9cd75ff","preferredLineEnding":null,"nextMarkerId":8,"deserializer":"TextBuffer","version":5},{"id":"61e4b992a6c794638f33b6bd74303793","text":"var expect = require('chai').expect;\nvar G = require('../generatorics');\n\ndescribe('Arithmetic functions', () => {\n  it('factorial works', () => {\n    expect(G.factorial(0)).to.equal(1);\n    expect(G.factorial(1)).to.equal(1);\n    expect(G.factorial(2)).to.equal(2);\n    expect(G.factorial(3)).to.equal(6);\n    expect(G.factorial(4)).to.equal(24);\n    expect(G.factorial(5)).to.equal(120);\n  });\n\n  it('factoradic works', () => {\n    expect(G.factoradic(0)).to.eql([ 0 ]);\n    expect(G.factoradic(1)).to.eql([ 0, 1 ]);\n    expect(G.factoradic(2)).to.eql([ 0, 0, 1 ]);\n    expect(G.factoradic(3)).to.eql([ 0, 1, 1 ]);\n    expect(G.factoradic(100)).to.eql([ 0, 0, 2, 0, 4 ]);\n    expect(G.factoradic(1337)).to.eql([ 0, 1, 2, 2, 0, 5, 1 ]);\n    expect(G.factoradic(9001)).to.eql([ 0, 1, 0, 0, 0, 3, 5, 1 ]);\n    expect(G.factoradic(3958174309503149571029856012)).to.eql([ 0, 1, 0, 2, 2, 3, 5, 5, 2, 2, 3, 7, 6, 1, 12, 14, 11, 12, 18, 0, 10, 2, 21, 12, 4, 21, 9 ]);\n  });\n\n  it('P(n,r) works', () => {\n    expect(G.P(10, 3)).to.equal(720);\n    expect(G.P(10, 1)).to.equal(10);\n    expect(G.P(10, 0)).to.equal(1);\n    expect(G.P(10, 10)).to.equal(3628800);\n  });\n\n  it('C(n,r) works', () => {\n    expect(G.C(10, 3)).to.equal(120);\n    expect(G.C(10, 1)).to.equal(10);\n    expect(G.C(10, 0)).to.equal(1);\n    expect(G.C(10, 10)).to.equal(1);\n  });\n});\n\ndescribe('Combinations', () => {\n  it('should get combinations of two from set of 3', () => {\n    var members = [\n      [ 1, 2 ],\n      [ 1, 3 ],\n      [ 2, 3 ]\n    ];\n    var answers = [];\n    for (var comb of G.combination([1, 2, 3], 2)) {\n      answers.push(comb.slice());\n    }\n    expect(answers).to.deep.have.members(members);\n  });\n\n  it('should work with size 1', () => {\n    var members = [\n      [ 1 ],\n      [ 2 ],\n      [ 3 ]\n    ];\n    var answers = [];\n    for (var comb of G.combination([1, 2, 3], 1)) {\n      answers.push(comb.slice());\n    }\n    expect(answers).to.deep.have.members(members);\n  });\n\n  it('should work with size 0', () => {\n    for (var comb of G.combination([1, 2, 3], 0)) {\n      expect(comb).to.eql([]);\n    }\n  });\n\n  it('should yield nothing if size is greater than array length', () => {\n    for (var comb of G.combination([1, 2, 3], 4)) {\n      throw new Error('Made a combination when it should not have');\n    }\n  });\n\n  it('combinations should default to arr.length without size specified', () => {\n    for (var comb of G.combination([1, 2, 3])) {\n      expect(comb).to.eql([1, 2, 3]);\n    }\n  });\n\n  it('should work with strings', () => {\n    var members = [\n      [ 'a', 'b' ],\n      [ 'a', 'c' ],\n      [ 'a', 'd' ],\n      [ 'b', 'c' ],\n      [ 'b', 'd' ],\n      [ 'c', 'd' ],\n    ];\n    var answers = [];\n    for (var comb of G.combination('abcd', 2)) {\n      answers.push(comb.slice());\n    }\n    expect(answers).to.deep.have.members(members);\n  });\n\n});\n\ndescribe('Permutations', () => {\n\n  it('should get permutations of 2 from a set of 3', () => {\n    var members = [\n      [ 1, 2 ],\n      [ 1, 3 ],\n      [ 2, 1 ],\n      [ 2, 3 ],\n      [ 3, 1 ],\n      [ 3, 2 ]\n    ];\n    var answers = [];\n    for (var perm of G.permutation([1, 2, 3], 2)) {\n      answers.push(perm.slice());\n    }\n    expect(answers).to.deep.have.members(members);\n  });\n\n  it('should work with size 1', () => {\n    var members = [\n      [ 1 ],\n      [ 2 ],\n      [ 3 ]\n    ];\n    var answers = [];\n    for (var perm of G.permutation([1, 2, 3], 1)) {\n      answers.push(perm.slice());\n    }\n    expect(answers).to.deep.have.members(members);\n  });\n\n  it('should work with size 0', () => {\n    for (var perm of G.permutation([1, 2, 3], 0)) {\n      expect(perm).to.eql([]);\n    }\n  });\n\n  it('should yield nothing if size is greater than array length', () => {\n    for (var perm of G.permutation([1, 2, 3], 4)) {\n      throw new Error('Made a permutation when it should not have');\n    }\n  });\n\n  it('permutations should default to arr.length without size specified', () => {\n    var members = [\n      [ 1, 2, 3 ],\n      [ 1, 3, 2 ],\n      [ 2, 1, 3 ],\n      [ 2, 3, 1 ],\n      [ 3, 2, 1 ],\n      [ 3, 1, 2 ],\n    ];\n    var answers = [];\n    for (var perm of G.permutation([1, 2, 3])) {\n      answers.push(perm.slice());\n    }\n    expect(answers).to.deep.have.members(members);\n  });\n\n  it('should work with strings', () => {\n    var members = [\n      [ 'a', 'b' ],\n      [ 'a', 'c' ],\n      [ 'a', 'd' ],\n      [ 'b', 'a' ],\n      [ 'b', 'c' ],\n      [ 'b', 'd' ],\n      [ 'c', 'a' ],\n      [ 'c', 'b' ],\n      [ 'c', 'd' ],\n      [ 'd', 'a' ],\n      [ 'd', 'b' ],\n      [ 'd', 'c' ],\n    ];\n    var answers = [];\n    for (var perm of G.permutation('abcd', 2)) {\n      answers.push(perm.slice());\n    }\n    expect(answers).to.deep.have.members(members);\n  });\n\n});\n\ndescribe('Base N', () => {\n\n  it('should get number of 2 digits a set of 3', () => {\n    var members = [\n      [ 1, 1 ],\n      [ 1, 2 ],\n      [ 1, 3 ],\n      [ 2, 1 ],\n      [ 2, 2 ],\n      [ 2, 3 ],\n      [ 3, 1 ],\n      [ 3, 2 ],\n      [ 3, 3 ],\n    ];\n    var answers = [];\n    for (var perm of G.baseN([1, 2, 3], 2)) {\n      answers.push(perm.slice());\n    }\n    expect(answers).to.deep.have.members(members);\n  });\n\n  it('should work with size 1', () => {\n    var members = [\n      [ 1 ],\n      [ 2 ],\n      [ 3 ]\n    ];\n    var answers = [];\n    for (var perm of G.baseN([1, 2, 3], 1)) {\n      answers.push(perm.slice());\n    }\n    expect(answers).to.deep.have.members(members);\n  });\n\n  it('should work with size 0', () => {\n    for (var perm of G.baseN([1, 2, 3], 0)) {\n      expect(perm).to.eql([]);\n    }\n  });\n\n  it('baseN should default to arr.length without size specified', () => {\n    var members = [\n      [ 1, 1, 1 ],\n      [ 1, 1, 2 ],\n      [ 1, 1, 3 ],\n      [ 1, 2, 1 ],\n      [ 1, 2, 2 ],\n      [ 1, 2, 3 ],\n      [ 1, 3, 1 ],\n      [ 1, 3, 2 ],\n      [ 1, 3, 3 ],\n      [ 2, 1, 1 ],\n      [ 2, 1, 2 ],\n      [ 2, 1, 3 ],\n      [ 2, 2, 1 ],\n      [ 2, 2, 2 ],\n      [ 2, 2, 3 ],\n      [ 2, 3, 1 ],\n      [ 2, 3, 2 ],\n      [ 2, 3, 3 ],\n      [ 3, 1, 1 ],\n      [ 3, 1, 2 ],\n      [ 3, 1, 3 ],\n      [ 3, 2, 1 ],\n      [ 3, 2, 2 ],\n      [ 3, 2, 3 ],\n      [ 3, 3, 1 ],\n      [ 3, 3, 2 ],\n      [ 3, 3, 3 ],\n    ];\n    var answers = [];\n    for (var perm of G.baseN([1, 2, 3])) {\n      answers.push(perm.slice());\n    }\n    expect(answers).to.deep.have.members(members);\n  });\n\n});\n\n\ndescribe('Power Set', () => {\n\n  it('should calculate power set', () => {\n    var members = [\n      [  ],\n      [ 1 ],\n      [ 2 ],\n      [ 1, 2 ],\n      [ 3 ],\n      [ 1, 3 ],\n      [ 2, 3 ],\n      [ 1, 2, 3 ]\n    ];\n    var answers = [];\n    for (var sett of G.powerSet([1, 2, 3])) {\n      answers.push(sett.slice());\n    }\n    expect(answers).to.deep.have.members(members);\n  });\n\n});\n\ndescribe('Permutation Combination', () => {\n\n  it('should get the permutation of combinations', () => {\n    var members = [\n      [ ],\n      [ 'a' ],\n      [ 'b' ],\n      [ 'c' ],\n      [ 'a', 'b' ],\n      [ 'b', 'a' ],\n      [ 'a', 'c' ],\n      [ 'c', 'a' ],\n      [ 'b', 'c' ],\n      [ 'c', 'b' ],\n      [ 'a', 'b', 'c' ],\n      [ 'a', 'c', 'b' ],\n      [ 'b', 'a', 'c' ],\n      [ 'b', 'c', 'a' ],\n      [ 'c', 'a', 'b' ],\n      [ 'c', 'b', 'a' ]\n    ];\n    var answers = [];\n    for (var comb of G.permutationCombination(['a', 'b', 'c'])) {\n      answers.push(comb.slice());\n    }\n    expect(answers).to.deep.have.members(members);\n  });\n\n});\n\ndescribe('Cartesian Product', () => {\n\n  it('should find the cartesian product of a bunch of arrays', () => {\n    var members = [\n      [0, 0, 0],   [1, 0, 0],   [2, 0, 0],\n      [0, 10, 0],  [1, 10, 0],  [2, 10, 0],\n      [0, 20, 0],  [1, 20, 0],  [2, 20, 0],\n      [0, 0, 100], [1, 0, 100], [2, 0, 100],\n      [0, 10, 100],[1, 10, 100],[2, 10, 100],\n      [0, 20, 100],[1, 20, 100],[2, 20, 100],\n      [0, 0, 200], [1, 0, 200], [2, 0, 200],\n      [0, 10, 200],[1, 10, 200],[2, 10, 200],\n      [0, 20, 200],[1, 20, 200],[2, 20, 200]\n    ];\n    var answers = [];\n    for (var sett of G.cartesian([0, 1, 2], [0, 10, 20], [0, 100, 200])) {\n      answers.push(sett.slice());\n    }\n    expect(answers).to.deep.have.members(members);\n  });\n\n  it('should work with apply', () => {\n    var members = [\n      [0, 0, 0],   [1, 0, 0],   [2, 0, 0],\n      [0, 10, 0],  [1, 10, 0],  [2, 10, 0],\n      [0, 20, 0],  [1, 20, 0],  [2, 20, 0],\n      [0, 0, 100], [1, 0, 100], [2, 0, 100],\n      [0, 10, 100],[1, 10, 100],[2, 10, 100],\n      [0, 20, 100],[1, 20, 100],[2, 20, 100],\n      [0, 0, 200], [1, 0, 200], [2, 0, 200],\n      [0, 10, 200],[1, 10, 200],[2, 10, 200],\n      [0, 20, 200],[1, 20, 200],[2, 20, 200]\n    ];\n    var answers = [];\n    for (var sett of G.cartesian.apply(G, [[0, 1, 2], [0, 10, 20], [0, 100, 200]])) {\n      answers.push(sett.slice());\n    }\n    expect(answers).to.deep.have.members(members);\n  });\n\n  it('should work with apply', () => {\n    var members = [\n      [ 'a', 'c', 'e' ],\n      [ 'a', 'c', 'f' ],\n      [ 'a', 'd', 'e' ],\n      [ 'a', 'd', 'f' ],\n      [ 'b', 'c', 'e' ],\n      [ 'b', 'c', 'f' ],\n      [ 'b', 'd', 'e' ],\n      [ 'b', 'd', 'f' ]\n    ];\n    var answers = [];\n    for (var sett of G.cartesian('ab', 'cd', 'ef')) {\n      answers.push(sett.slice());\n    }\n    expect(answers).to.deep.have.members(members);\n  });\n\n});\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"id":"0","maintainHistory":false,"markersById":{"2":{"range":{"start":{"row":73,"column":0},"end":{"row":73,"column":1}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap"},"3":{"range":{"start":{"row":140,"column":0},"end":{"row":140,"column":1}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"overlap"}},"version":2},"1":{"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"id":"2","maintainHistory":true,"markersById":{"1":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2},"3":{"id":"3","maintainHistory":false,"markersById":{},"version":2},"4":{"id":"4","maintainHistory":false,"markersById":{},"version":2}},"nextMarkerLayerId":5,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/home/andy/Desktop/bower_components/generatorics/test/index.js","digestWhenLastPersisted":"f71fa8d51c132a86f8d78fe7e51f28b0e05388e4","preferredLineEnding":null,"nextMarkerId":4,"deserializer":"TextBuffer","version":5},{"id":"025d51b7ef1d3893446587f1bec8fd1f","text":"/*\n *  Licensed under the MIT license.\n *  http://www.opensource.org/licenses/mit-license.php\n *\n *  References:\n *    http://www.ruby-doc.org/core-2.0/Array.html#method-i-combination\n *    http://www.ruby-doc.org/core-2.0/Array.html#method-i-permutation\n *    http://en.wikipedia.org/wiki/Factorial_number_system\n */\n\n(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.G = factory();\n  }\n}(this, function() {\n\n'use strict';\n\n/** @exports G */\nvar G = {\n\n  /**\n   * Calculates a factorial\n   * @param {Number} n - The number to operate the factorial on.\n   * @returns {Number} n!\n   */\n  factorial: function factorial(n) {\n    for (var ans = 1; n; ans *= n--);\n    return ans;\n  },\n\n  /**\n   * Converts a number to the factorial number system. Digits are in least significant order.\n   * @param {Number} n - Integer in base 10\n   * @returns {Array} digits of n in factoradic in least significant order\n   */\n  factoradic: function factoradic(n) {\n    var f = 1;\n    for (var d = 1; f < n; f *= ++d);\n    if (f > n) f /= d--;\n    var result = [0];\n    for (; d; f /= d--) {\n      result[d] = Math.floor(n / f);\n      n %= f;\n    }\n    return result;\n  },\n\n  /**\n   * Calculates the number of possible permutations of \"r\" elements in a set of size \"n\".\n   * @param {Number} n - Number of elements in the set.\n   * @param {Number} r - Number of elements to choose from the set.\n   * @returns {Number} n P r\n   */\n  P: function P(n, r) {\n    return this.factorial(n) / this.factorial(n - r);\n  },\n\n  /**\n   * Calculates the number of possible combinations of \"r\" elements in a set of size \"n\".\n   * @param {Number} n - Number of elements in the set.\n   * @param {Number} r - Number of elements to choose from the set.\n   * @returns {Number} n C r\n   */\n  C: function C(n, r) {\n    return this.P(n, r) / this.factorial(r);\n  },\n\n  /**\n   * Generates all combinations of a set.\n   * @param {Array|String} arr - The set of elements.\n   * @param {Number} [size=arr.length] - Number of elements to choose from the set.\n   * @returns {Generator} yields each combination as an array\n   */\n  combination: function* combination(arr, size) {\n    size = typeof size === 'undefined' ? arr.length : size;\n    var end = arr.length - 1;\n    var data = [];\n    yield* combinationUtil(0, 0);\n    function* combinationUtil(start, index) {\n      if (index === size) { // Current combination is ready to be processed, yield the combination\n        return yield data;\n      }\n      // replace index with all possible elements. The condition\n      // \"end - i + 1 >= size - index\" makes sure that including one element\n      // at index will make a combination with remaining elements\n      // at remaining positions\n      for (var i = start; i <= end && end - i + 1 >= size - index; i++) {\n        data[index] = arr[i];\n        yield* combinationUtil(i + 1, index + 1);\n      }\n    }\n  },\n\n  /**\n   * Generates all permutations of a set.\n   * @param {Array|String} arr - The set of elements.\n   * @param {Number} [size=arr.length] - Number of elements to choose from the set.\n   * @returns {Generator} yields each permutation as an array\n   */\n  permutation: function* permutation(arr, size) {\n    size = typeof size === 'undefined' ? arr.length : size;\n    if (size === arr.length) {\n      return yield* heapsAlg(arr);\n    }\n    var data = [];\n    var indecesUsed = [];\n    yield* permutationUtil(0);\n    function* permutationUtil(index) {\n      if (index === size) {\n        return yield data;\n      }\n      for (var i = 0; i < arr.length; i++) {\n        if (!indecesUsed[i]) {\n          indecesUsed[i] = true;\n          data[index] = arr[i];\n          yield *permutationUtil(index + 1);\n          indecesUsed[i] = false;\n        }\n      }\n    }\n  },\n\n  /**\n  * Generates all possible subsets of a set (a.k.a. power set).\n  * @param {Array|String} arr - The set of elements.\n  * @returns {Generator} yields each subset as an array\n  */\n  powerSet: function* powerSet(arr) {\n    var data = [];\n    yield* powerUtil(0, 0);\n    function* powerUtil(start, index) {\n      data.length = index;\n      yield data;\n      if (index === arr.length) {\n        return;\n      }\n      for (var i = start; i < arr.length; i++) {\n        data[index] = arr[i];\n        yield* powerUtil(i + 1, index + 1);\n      }\n    }\n  },\n\n  /**\n   * Generates the permutation of the combinations of a set.\n   * @param {Array|String} arr - The set of elements.\n   * @returns {Generator} yields each permutation as an array\n   */\n  permutationCombination: function* permutationCombination(arr) {\n    var data = [];\n    var indecesUsed = [];\n    yield* permutationUtil(0);\n    function* permutationUtil(index) {\n      data.length = index;\n      yield data;\n      if (index === arr.length) {\n        return;\n      }\n      for (var i = 0; i < arr.length; i++) {\n        if (!indecesUsed[i]) {\n          indecesUsed[i] = true;\n          data[index] = arr[i];\n          yield *permutationUtil(index + 1);\n          indecesUsed[i] = false;\n        }\n      }\n    }\n  },\n\n  /**\n   * Generates all possible \"numbers\" from the digits of a set.\n   * @param {Array|String} arr - The set of digits.\n   * @param {Number} [size=arr.length] - How many digits will be in the numbers.\n   * @returns {Generator} yields all digits as an array\n   */\n  baseN: function* baseN(arr, size) {\n    size = typeof size === 'undefined' ? arr.length : size;\n    var data = [];\n    yield* baseNUtil(0);\n    function* baseNUtil(index) {\n      if (index === size) {\n        return yield data;\n      }\n      for (var i = 0; i < arr.length; i++) {\n        data[index] = arr[i];\n        yield* baseNUtil(index + 1);\n      }\n    }\n  },\n\n  /**\n   * Generates the cartesian product of the sets.\n   * @param {...(Array|String)} sets - Variable number of sets of n elements.\n   * @returns {Generator} yields each product as an array\n   */\n  cartesian: function* cartesian(sets) {\n    sets = arguments;\n    var data = [];\n    yield* cartesianUtil(0);\n    function* cartesianUtil(index) {\n      if (index === sets.length) {\n        return yield data;\n      }\n      for (var i = 0; i < sets[index].length; i++) {\n        data[index] = sets[index][i];\n        yield* cartesianUtil(index + 1);\n      }\n    }\n  }\n\n};\n\n\n/*\n * More efficient alorithm for permutations of All elements in an array. Doesn't\n * work for \"sub-permutations\", e.g. permutations of 3 elements from [1, 2, 3, 4, 5]\n */\nfunction* heapsAlg(arr) {\n  var size = arr.length;\n  yield* heapsUtil(0);\n  function* heapsUtil(index) {\n    if (index === size) {\n      return yield arr;\n    }\n\n    for (var j = index; j < size; j++) {\n      swap(arr, index, j);\n      yield* heapsUtil(index + 1);\n      swap(arr, index, j);\n    }\n  }\n}\n\n/*\n * Swaps two array elements.\n */\nfunction swap(arr, i, j) {\n  var len = arr.length;\n  if (i >= len || j >= len) {\n    console.warn('Swapping an array\\'s elements past its length.');\n  }\n  var temp = arr[j];\n  arr[j] = arr[i];\n  arr[i] = temp;\n  return arr;\n}\n\n\nreturn G;\n\n}));\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"id":"2","maintainHistory":true,"markersById":{"1":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection","preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2},"3":{"id":"3","maintainHistory":false,"markersById":{},"version":2},"4":{"id":"4","maintainHistory":false,"markersById":{},"version":2}},"nextMarkerLayerId":5,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/home/andy/Desktop/bower_components/generatorics/generatorics.js","digestWhenLastPersisted":"9462b7785bf8e0bb33f3dbb7d806d463be3acc26","preferredLineEnding":null,"nextMarkerId":2,"deserializer":"TextBuffer","version":5},{"id":"3e88c56323da8d13de602988f29ff216","text":"# Generatorics\n\n### A combinatorics library for JavaScript utilizing ES2015 generators. Generate combinations, permutations, and power sets of arrays or strings.\n\n- Node\n```\nnpm install generatorics\n```\n```javascript\nvar G = require('generatorics');\n```\n\n- Browser\n```\nbower install generatorics\n```\n```html\n<script src=\"file/path/to/generatorics.js\"></script>\n```\n\n\n## Usage\n\n### Power Set\n```javascript\nfor (var subset of G.powerSet(['a', 'b', 'c'])) {\n  console.log(subset);\n}\n//  [ ]\n//  [ 'a' ]\n//  [ 'b' ]\n//  [ 'a', 'b' ]\n//  [ 'c' ]\n//  [ 'a', 'c' ]\n//  [ 'b', 'c' ]\n//  [ 'a', 'b', 'c' ]\n```\n\n### permutation\n```javascript\nfor (var perm of G.permutation(['a', 'b', 'c'], 2)) {\n  console.log(perm);\n}\n// [ 'a', 'b' ]\n// [ 'a', 'c' ]\n// [ 'b', 'a' ]\n// [ 'b', 'c' ]\n// [ 'c', 'a' ]\n// [ 'c', 'b' ]\n\nfor (var perm of G.permutation(['a', 'b', 'c'])) { // assumes full length of array\n  console.log(perm);\n}\n// [ 'a', 'b', 'c' ]\n// [ 'a', 'c', 'b' ]\n// [ 'b', 'a', 'c' ]\n// [ 'b', 'c', 'a' ]\n// [ 'c', 'b', 'a' ]\n// [ 'c', 'a', 'b' ]\n```\n\n### combination\n```javascript\nfor (var comb of G.combination(['a', 'b', 'c'], 2)) {\n  console.log(comb);\n}\n// [ 'a', 'b' ]\n// [ 'a', 'c' ]\n// [ 'b', 'c' ]\n```\n\n### permutation of combination\n```javascript\nfor (var perm of G.permutationCombination(['a', 'b', 'c'])) {\n  console.log(perm);\n}\n// [ ]\n// [ 'a' ]\n// [ 'a', 'b' ]\n// [ 'a', 'b', 'c' ]\n// [ 'a', 'c' ]\n// [ 'a', 'c', 'b' ]\n// [ 'b' ]\n// [ 'b', 'a' ]\n// [ 'b', 'a', 'c' ]\n// [ 'b', 'c' ]\n// [ 'b', 'c', 'a' ]\n// [ 'c' ]\n// [ 'c', 'a' ]\n// [ 'c', 'a', 'b' ]\n// [ 'c', 'b' ]\n// [ 'c', 'b', 'a' ]\n```\n\n### cartesian product\n```javascript\nfor (var prod of G.cartesian([0, 1, 2], [0, 10, 20], [0, 100, 200])) {\n  console.log(prod);\n}\n// [ 0, 0, 0 ],  [ 0, 0, 100 ],  [ 0, 0, 200 ]\n// [ 0, 10, 0 ], [ 0, 10, 100 ], [ 0, 10, 200 ]\n// [ 0, 20, 0 ], [ 0, 20, 100 ], [ 0, 20, 200 ]\n// [ 1, 0, 0 ],  [ 1, 0, 100 ],  [ 1, 0, 200 ]\n// [ 1, 10, 0 ], [ 1, 10, 100 ], [ 1, 10, 200 ]\n// [ 1, 20, 0 ], [ 1, 20, 100 ], [ 1, 20, 200 ]\n// [ 2, 0, 0 ],  [ 2, 0, 100 ],  [ 2, 0, 200 ]\n// [ 2, 10, 0 ], [ 2, 10, 100 ], [ 2, 10, 200 ]\n// [ 2, 20, 0 ], [ 2, 20, 100 ], [ 2, 20, 200 ]\n```\n\n### base N\n```javascript\nfor (var num of G.baseN(['a', 'b', 'c'])) {\n  console.log(num);\n}\n// [ 'a', 'a', 'a' ], [ 'a', 'a', 'b' ], [ 'a', 'a', 'c' ]\n// [ 'a', 'b', 'a' ], [ 'a', 'b', 'b' ], [ 'a', 'b', 'c' ]\n// [ 'a', 'c', 'a' ], [ 'a', 'c', 'b' ], [ 'a', 'c', 'c' ]\n// [ 'b', 'a', 'a' ], [ 'b', 'a', 'b' ], [ 'b', 'a', 'c' ]\n// [ 'b', 'b', 'a' ], [ 'b', 'b', 'b' ], [ 'b', 'b', 'c' ]\n// [ 'b', 'c', 'a' ], [ 'b', 'c', 'b' ], [ 'b', 'c', 'c' ]\n// [ 'c', 'a', 'a' ], [ 'c', 'a', 'b' ], [ 'c', 'a', 'c' ]\n// [ 'c', 'b', 'a' ], [ 'c', 'b', 'b' ], [ 'c', 'b', 'c' ]\n// [ 'c', 'c', 'a' ], [ 'c', 'c', 'b' ], [ 'c', 'c', 'c' ]\n```\n\n## Documentation\n\n<a name=\"module_G\"></a>\n## G\n\n* [G](#module_G)\n    * [.factorial(n)](#module_G.factorial) ⇒ <code>Number</code>\n    * [.factoradic(n)](#module_G.factoradic) ⇒ <code>Array</code>\n    * [.P(n, r)](#module_G.P) ⇒ <code>Number</code>\n    * [.C(n, r)](#module_G.C) ⇒ <code>Number</code>\n    * [.combination(arr, [size])](#module_G.combination) ⇒ <code>Generator</code>\n    * [.permutation(arr, [size])](#module_G.permutation) ⇒ <code>Generator</code>\n    * [.powerSet(arr)](#module_G.powerSet) ⇒ <code>Generator</code>\n    * [.permutationCombination(arr)](#module_G.permutationCombination) ⇒ <code>Generator</code>\n    * [.baseN(arr, [size])](#module_G.baseN) ⇒ <code>Generator</code>\n    * [.cartesian(...sets)](#module_G.cartesian) ⇒ <code>Generator</code>\n\n<a name=\"module_G.factorial\"></a>\n### G.factorial(n) ⇒ <code>Number</code>\nCalculates a factorial\n\n**Kind**: static method of <code>[G](#module_G)</code>  \n**Returns**: <code>Number</code> - n!  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| n | <code>Number</code> | The number to operate the factorial on. |\n\n<a name=\"module_G.factoradic\"></a>\n### G.factoradic(n) ⇒ <code>Array</code>\nConverts a number to the factorial number system. Digits are in least significant order.\n\n**Kind**: static method of <code>[G](#module_G)</code>  \n**Returns**: <code>Array</code> - digits of n in factoradic in least significant order  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| n | <code>Number</code> | Integer in base 10 |\n\n<a name=\"module_G.P\"></a>\n### G.P(n, r) ⇒ <code>Number</code>\nCalculates the number of possible permutations of \"r\" elements in a set of size \"n\".\n\n**Kind**: static method of <code>[G](#module_G)</code>  \n**Returns**: <code>Number</code> - n P r  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| n | <code>Number</code> | Number of elements in the set. |\n| r | <code>Number</code> | Number of elements to choose from the set. |\n\n<a name=\"module_G.C\"></a>\n### G.C(n, r) ⇒ <code>Number</code>\nCalculates the number of possible combinations of \"r\" elements in a set of size \"n\".\n\n**Kind**: static method of <code>[G](#module_G)</code>  \n**Returns**: <code>Number</code> - n C r  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| n | <code>Number</code> | Number of elements in the set. |\n| r | <code>Number</code> | Number of elements to choose from the set. |\n\n<a name=\"module_G.combination\"></a>\n### G.combination(arr, [size]) ⇒ <code>Generator</code>\nGenerates all combinations of a set.\n\n**Kind**: static method of <code>[G](#module_G)</code>  \n**Returns**: <code>Generator</code> - yields each combination as an array  \n\n| Param | Type | Default | Description |\n| --- | --- | --- | --- |\n| arr | <code>Array</code> &#124; <code>String</code> |  | The set of elements. |\n| [size] | <code>Number</code> | <code>arr.length</code> | Number of elements to choose from the set. |\n\n<a name=\"module_G.permutation\"></a>\n### G.permutation(arr, [size]) ⇒ <code>Generator</code>\nGenerates all permutations of a set.\n\n**Kind**: static method of <code>[G](#module_G)</code>  \n**Returns**: <code>Generator</code> - yields each permutation as an array  \n\n| Param | Type | Default | Description |\n| --- | --- | --- | --- |\n| arr | <code>Array</code> &#124; <code>String</code> |  | The set of elements. |\n| [size] | <code>Number</code> | <code>arr.length</code> | Number of elements to choose from the set. |\n\n<a name=\"module_G.powerSet\"></a>\n### G.powerSet(arr) ⇒ <code>Generator</code>\nGenerates all possible subsets of a set (a.k.a. power set).\n\n**Kind**: static method of <code>[G](#module_G)</code>  \n**Returns**: <code>Generator</code> - yields each subset as an array  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| arr | <code>Array</code> &#124; <code>String</code> | The set of elements. |\n\n<a name=\"module_G.permutationCombination\"></a>\n### G.permutationCombination(arr) ⇒ <code>Generator</code>\nGenerates the permutation of the combinations of a set.\n\n**Kind**: static method of <code>[G](#module_G)</code>  \n**Returns**: <code>Generator</code> - yields each permutation as an array  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| arr | <code>Array</code> &#124; <code>String</code> | The set of elements. |\n\n<a name=\"module_G.baseN\"></a>\n### G.baseN(arr, [size]) ⇒ <code>Generator</code>\nGenerates all possible \"numbers\" from the digits of a set.\n\n**Kind**: static method of <code>[G](#module_G)</code>  \n**Returns**: <code>Generator</code> - yields all digits as an array  \n\n| Param | Type | Default | Description |\n| --- | --- | --- | --- |\n| arr | <code>Array</code> &#124; <code>String</code> |  | The set of digits. |\n| [size] | <code>Number</code> | <code>arr.length</code> | How many digits will be in the numbers. |\n\n<a name=\"module_G.cartesian\"></a>\n### G.cartesian(...sets) ⇒ <code>Generator</code>\nGenerates the cartesian product of the sets.\n\n**Kind**: static method of <code>[G](#module_G)</code>  \n**Returns**: <code>Generator</code> - yields each product as an array  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| ...sets | <code>Array</code> &#124; <code>String</code> | Variable number of sets of n elements. |\n\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"id":"2","maintainHistory":true,"markersById":{"1":{"range":{"start":{"row":0,"column":0},"end":{"row":0,"column":0}},"properties":{"type":"selection"},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2},"3":{"id":"3","maintainHistory":false,"markersById":{},"version":2}},"nextMarkerLayerId":4,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/home/andy/Desktop/bower_components/generatorics/README.md","digestWhenLastPersisted":"492f5ed49bb3b41edf56f80dc79d6d7ef8b0d218","preferredLineEnding":null,"nextMarkerId":40,"deserializer":"TextBuffer","version":5}]},"workspace":{"deserializer":"Workspace","paneContainer":{"deserializer":"PaneContainer","version":1,"root":{"deserializer":"Pane","id":3,"items":[{"deserializer":"TextEditor","id":4,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":5,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/home/andy/Desktop/bower_components/generatorics/.bower.json","bufferId":"cc561ac6c75132bfacd5e55dfef5711e","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":8,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":9,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/home/andy/Desktop/bower_components/generatorics/test/index.js","bufferId":"61e4b992a6c794638f33b6bd74303793","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":12,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":13,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/home/andy/Desktop/bower_components/generatorics/generatorics.js","bufferId":"025d51b7ef1d3893446587f1bec8fd1f","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":16,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":17,"softWrapped":true,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/home/andy/Desktop/bower_components/generatorics/README.md","bufferId":"3e88c56323da8d13de602988f29ff216","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"}],"activeItemURI":"/home/andy/Desktop/bower_components/generatorics/README.md","focused":false,"flexScale":1},"activePaneId":3},"packagesWithActiveGrammars":["language-json","language-javascript","language-gfm","language-html","language-hyperlink","language-todo"],"destroyedItemURIs":[]},"packageStates":{"pigments":{"project":{"deserializer":"ColorProject","timestamp":"2016-02-16T07:03:04.573Z","version":"1.0.1","markersVersion":"1.0.5","globalSourceNames":["**/*.styl","**/*.stylus","**/*.less","**/*.sass","**/*.scss"],"globalIgnoredNames":["vendor/*","node_modules/*","spec/*","test/*"],"buffers":{"4":{"id":4,"path":"/home/andy/Desktop/bower_components/generatorics/.bower.json","colorMarkers":[]},"8":{"id":8,"path":"/home/andy/Desktop/bower_components/generatorics/test/index.js","colorMarkers":[]},"12":{"id":12,"path":"/home/andy/Desktop/bower_components/generatorics/generatorics.js","colorMarkers":[]},"16":{"id":16,"path":"/home/andy/Desktop/bower_components/generatorics/README.md","colorMarkers":[]}},"paths":[],"variables":{"deserializer":"VariablesCollection","content":[]}}},"fuzzy-finder":{"/home/andy/Desktop/bower_components/generatorics/.bower.json":1455606127976,"/home/andy/Desktop/bower_components/generatorics/test/index.js":1455606135068,"/home/andy/Desktop/bower_components/generatorics/generatorics.js":1455606171596,"/home/andy/Desktop/bower_components/generatorics/README.md":1455606177428},"tabs":[{}],"tree-view":{"directoryExpansionStates":{"/home/andy/Desktop/bower_components":{"isExpanded":true,"entries":{"generatorics":{"isExpanded":true,"entries":{"test":{"isExpanded":true,"entries":{}}}}}}},"selectedPath":"/home/andy/Desktop/bower_components/generatorics/README.md","hasFocus":true,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}},"fullScreen":false}